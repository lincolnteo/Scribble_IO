<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/FirstName_LastName_StudentNumber_Ass2/code/PictionaryGame.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/FirstName_LastName_StudentNumber_Ass2/code/PictionaryGame.py" />
              <option name="originalContent" value="# Inspired by PyQt5 Creating Paint Application In 40 Minutes&#10;#  https://www.youtube.com/watch?v=qEgyGyVA1ZQ&#10;&#10;# NB If the menus do not work then click on another application and then click back&#10;# and they will work https://python-forum.io/Thread-Tkinter-macOS-Catalina-and-Python-menu-issue&#10;&#10;# PyQt documentation links are prefixed with the word 'documentation' in the code below and can be accessed automatically&#10;#  in PyCharm using the following technique https://www.jetbrains.com/help/pycharm/inline-documentation.html&#10;&#10;from PyQt6.QtWidgets import QApplication, QWidget, QMainWindow, QFileDialog, QDockWidget, QPushButton, QVBoxLayout, \&#10;    QLabel, QSizePolicy, QHBoxLayout, QRadioButton, QLineEdit&#10;from PyQt6.QtGui import QIcon, QPainter, QPen, QPixmap&#10;import sys&#10;import csv, random&#10;from PyQt6.QtCore import Qt, QPoint&#10;&#10;&#10;class PictionaryGame(QMainWindow):  # documentation https://doc.qt.io/qt-6/qwidget.html&#10;    '''&#10;    Painting Application class&#10;    '''&#10;&#10;    def __init__(self):&#10;        super().__init__()&#10;&#10;        # set window title&#10;        self.setWindowTitle(&quot;Pictionary Game - A2 Template&quot;)&#10;&#10;        # set the windows dimensions&#10;        top = 400&#10;        left = 400&#10;        width = 800&#10;        height = 600&#10;        self.setGeometry(top, left, width, height)&#10;&#10;        # set the icon&#10;        self.setWindowIcon(QIcon(&quot;./icons/paint-brush.png&quot;))&#10;&#10;        # canvas image&#10;        self.image = QPixmap(&quot;./icons/canvas.png&quot;)&#10;&#10;        mainWidget = QWidget()&#10;        self.setCentralWidget(mainWidget)&#10;        # Ensure the central widget expands to fill available space so docks&#10;        # will be at the window edges&#10;        mainWidget.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)&#10;&#10;        # draw settings (default)&#10;        self.drawing = False&#10;        self.brushSize = 3&#10;        self.brushColor = Qt.GlobalColor.black&#10;&#10;        # reference to last point recorded by mouse&#10;        self.lastPoint = QPoint()&#10;&#10;        # players and scores&#10;        self.players = [&quot;Player 1&quot;, &quot;Player 2&quot;]&#10;        self.playerNum = 0  # current drawer index&#10;        self.currentPlayerNum = self.playerNum  # shown in &quot;Current Turn&quot;&#10;        self.scores = [0 for _ in self.players]&#10;&#10;        # mode and words&#10;        self.mode = 'easy'&#10;        self.wordList = []&#10;        self.currentWord = &quot;&quot;&#10;&#10;        # guessing state&#10;        self.isGuessPhase = False&#10;        self.attemptsLeft = 0&#10;        self.guessOver = False&#10;&#10;        # Left dock (player info + guessing)&#10;        self.leftDock = QDockWidget()&#10;        self.leftDock.setAllowedAreas(Qt.DockWidgetArea.LeftDockWidgetArea)&#10;        self.leftDock.setFeatures(QDockWidget.DockWidgetFeature(0))&#10;        self.addDockWidget(Qt.DockWidgetArea.LeftDockWidgetArea, self.leftDock)&#10;&#10;        # widget inside the left Dock&#10;        playerInfo = QWidget()&#10;        self.leftLayout = QVBoxLayout()&#10;        playerInfo.setLayout(self.leftLayout)&#10;        playerInfo.setMaximumSize(200, self.height())&#10;&#10;        # Current turn&#10;        self.currentTurnLabel = QLabel(&quot;Current Turn:&quot;)&#10;        self.currentPlayerLabel = QLabel(f&quot;{self.players[self.currentPlayerNum]}&quot;)&#10;        self.leftLayout.addWidget(self.currentTurnLabel)&#10;        self.leftLayout.addWidget(self.currentPlayerLabel)&#10;        self.leftLayout.addSpacing(10)&#10;&#10;        # Scores&#10;        self.leftLayout.addWidget(QLabel(&quot;Scores:&quot;))&#10;        self.scoreLabels = [QLabel(f&quot;{self.players[0]}: {self.scores[0]}&quot;),&#10;                            QLabel(f&quot;{self.players[1]}: {self.scores[1]}&quot;)]&#10;        self.leftLayout.addWidget(self.scoreLabels[0])&#10;        self.leftLayout.addWidget(self.scoreLabels[1])&#10;        self.leftLayout.addSpacing(8)&#10;&#10;        # Play mode&#10;        self.leftLayout.addWidget(QLabel(&quot;Play Mode:&quot;))&#10;        self.radioEasy = QRadioButton(&quot;Easy&quot;)&#10;        self.radioHard = QRadioButton(&quot;Hard&quot;)&#10;        self.radioEasy.setChecked(True)&#10;        self.leftLayout.addWidget(self.radioEasy)&#10;        self.leftLayout.addWidget(self.radioHard)&#10;        self.radioEasy.toggled.connect(lambda checked: self.set_mode('easy') if checked else None)&#10;        self.radioHard.toggled.connect(lambda checked: self.set_mode('hard') if checked else None)&#10;        self.leftLayout.addSpacing(10)&#10;&#10;        # Current word (visible)&#10;        self.leftLayout.addWidget(QLabel(&quot;Current Word:&quot;))&#10;        self.wordLabel = QLabel(&quot;----------&quot;)&#10;        self.leftLayout.addWidget(self.wordLabel)&#10;        self.leftLayout.addSpacing(8)&#10;&#10;        # Guessing UI (always visible)&#10;        self.guessInput = QLineEdit()&#10;        self.guessInput.setPlaceholderText(&quot;Enter your guess here&quot;)&#10;        self.guessButton = QPushButton(&quot;Guess&quot;)&#10;        self.guessButton.clicked.connect(self.handle_guess)&#10;        self.attemptsLabel = QLabel(&quot;&quot;)&#10;        guessLayout = QVBoxLayout()&#10;        guessLayout.addWidget(self.guessInput)&#10;        guessLayout.addWidget(self.guessButton)&#10;        guessLayout.addWidget(self.attemptsLabel)&#10;        self.leftLayout.addLayout(guessLayout)&#10;&#10;        # Next Turn button&#10;        self.nextTurnButton = QPushButton(&quot;Next Turn&quot;)&#10;        self.nextTurnButton.clicked.connect(self.next_turn)&#10;        self.leftLayout.addWidget(self.nextTurnButton)&#10;&#10;        # style left dock&#10;        playerInfo.setAutoFillBackground(True)&#10;        p = playerInfo.palette()&#10;        p.setColor(playerInfo.backgroundRole(), Qt.GlobalColor.lightGray)&#10;        playerInfo.setPalette(p)&#10;        self.leftDock.setWidget(playerInfo)&#10;&#10;        # Right dock (tools)&#10;        self.rightDock = QDockWidget()&#10;        self.rightDock.setAllowedAreas(Qt.DockWidgetArea.RightDockWidgetArea)&#10;        self.rightDock.setFeatures(QDockWidget.DockWidgetFeature(0))&#10;        self.addDockWidget(Qt.DockWidgetArea.RightDockWidgetArea, self.rightDock)&#10;&#10;        # widget inside the right Dock&#10;        colorPalette = QWidget()&#10;        self.rightLayout = QVBoxLayout()&#10;        colorPalette.setLayout(self.rightLayout)&#10;        colorPalette.setMaximumSize(200, self.height())&#10;&#10;        # Color palette controls&#10;        self.rightLayout.addWidget(QLabel(&quot;Color Palette:&quot;))&#10;        self.rightLayout.addSpacing(6)&#10;&#10;        self.btn_black = QPushButton(&quot;Black&quot;)&#10;        self.btn_black.setStyleSheet(&quot;background-color: #000000; color: #ffffff;&quot;)&#10;        self.btn_black.clicked.connect(self.black)&#10;        self.rightLayout.addWidget(self.btn_black)&#10;&#10;        self.btn_red = QPushButton(&quot;Red&quot;)&#10;        self.btn_red.setStyleSheet(&quot;background-color: #cc0000; color: #ffffff;&quot;)&#10;        self.btn_red.clicked.connect(self.red)&#10;        self.rightLayout.addWidget(self.btn_red)&#10;&#10;        self.btn_green = QPushButton(&quot;Green&quot;)&#10;        self.btn_green.setStyleSheet(&quot;background-color: #008800; color: #ffffff;&quot;)&#10;        self.btn_green.clicked.connect(self.green)&#10;        self.rightLayout.addWidget(self.btn_green)&#10;&#10;        self.btn_yellow = QPushButton(&quot;Yellow&quot;)&#10;        self.btn_yellow.setStyleSheet(&quot;background-color: #ffdd00; color: #000000;&quot;)&#10;        self.btn_yellow.clicked.connect(self.yellow)&#10;        self.rightLayout.addWidget(self.btn_yellow)&#10;        self.rightLayout.addStretch(1)&#10;&#10;        # Visual status and brush sizes&#10;        self.rightLayout.addWidget(QLabel(&quot;Current:&quot;))&#10;        swatchLayout = QHBoxLayout()&#10;        self.colorIndicator = QLabel()&#10;        self.colorIndicator.setFixedSize(20, 20)&#10;        self.colorIndicator.setStyleSheet(&quot;background-color: #000000; border: 1px solid #000000;&quot;)&#10;        swatchLayout.addWidget(self.colorIndicator)&#10;        self.colorNameLabel = QLabel(&quot;Black&quot;)&#10;        swatchLayout.addWidget(self.colorNameLabel)&#10;        self.sizeLabel = QLabel(f&quot;{self.brushSize} px&quot;)&#10;        swatchLayout.addWidget(self.sizeLabel)&#10;        swatchLayout.addStretch(1)&#10;        self.rightLayout.addLayout(swatchLayout)&#10;        self.rightLayout.addSpacing(6)&#10;&#10;        # Brush size buttons&#10;        self.rightLayout.addWidget(QLabel(&quot;Brush Sizes:&quot;))&#10;        self.threePxButton = QPushButton(&quot;3 px&quot;)&#10;        self.threePxButton.clicked.connect(self.threepx)&#10;        self.rightLayout.addWidget(self.threePxButton)&#10;&#10;        self.fivePxButton = QPushButton(&quot;5 px&quot;)&#10;        self.fivePxButton.clicked.connect(self.fivepx)&#10;        self.rightLayout.addWidget(self.fivePxButton)&#10;&#10;        self.sevenPxButton = QPushButton(&quot;7 px&quot;)&#10;        self.sevenPxButton.clicked.connect(self.sevenpx)&#10;        self.rightLayout.addWidget(self.sevenPxButton)&#10;&#10;        self.ninePxButton = QPushButton(&quot;9 px&quot;)&#10;        self.ninePxButton.clicked.connect(self.ninepx)&#10;        self.rightLayout.addWidget(self.ninePxButton)&#10;&#10;        self.rightLayout.addStretch(1)&#10;&#10;        # Clear and Save buttons&#10;        self.clearButton = QPushButton(&quot;Clear Canvas&quot;)&#10;        self.clearButton.clicked.connect(self.clear)&#10;        self.rightLayout.addWidget(self.clearButton)&#10;&#10;        self.saveButton = QPushButton(&quot;Save Canvas&quot;)&#10;        self.saveButton.clicked.connect(self.save)&#10;        self.rightLayout.addWidget(self.saveButton)&#10;&#10;        # right dock appearance&#10;        colorPalette.setAutoFillBackground(True)&#10;        p = colorPalette.palette()&#10;        p.setColor(colorPalette.backgroundRole(), Qt.GlobalColor.lightGray)&#10;        colorPalette.setPalette(p)&#10;        self.rightDock.setWidget(colorPalette)&#10;&#10;        # Load initial words and pick one&#10;        self.getList(self.mode)&#10;        self.currentWord = self.getWord()&#10;        self.wordLabel.setText(self.currentWord)&#10;&#10;    # event handlers&#10;    def mousePressEvent(self,event):  # when the mouse is pressed, documentation: https://doc.qt.io/qt-6/qwidget.html#mousePressEvent&#10;        if event.button() == Qt.MouseButton.LeftButton:  # if the pressed button is the left button&#10;            self.drawing = True  # enter drawing mode&#10;            self.lastPoint = event.pos()  # save the location of the mouse press as the lastPoint&#10;            print(self.lastPoint)  # print the lastPoint for debugging purposes&#10;&#10;    def mouseMoveEvent(self,event):  # when the mouse is moved, documenation: documentation: https://doc.qt.io/qt-6/qwidget.html#mouseMoveEvent&#10;        if self.drawing:&#10;            painter = QPainter(self.image)  # object which allows drawing to take place on an image&#10;            # allows the selection of brush colour, brish size, line type, cap type, join type. Images available here http://doc.qt.io/qt-6/qpen.html&#10;            painter.setPen(QPen(self.brushColor, self.brushSize, Qt.PenStyle.SolidLine, Qt.PenCapStyle.RoundCap,Qt.PenJoinStyle.RoundJoin))&#10;            painter.drawLine(self.lastPoint,event.pos())  # draw a line from the point of the orginal press to the point to where the mouse was dragged to&#10;            self.lastPoint = event.pos()  # set the last point to refer to the point we have just moved to, this helps when drawing the next line segment&#10;            self.update()  # call the update method of the widget which calls the paintEvent of this class&#10;&#10;    def mouseReleaseEvent(self,event):  # when the mouse is released, documentation: https://doc.qt.io/qt-6/qwidget.html#mouseReleaseEvent&#10;        if event.button() == Qt.MouseButton.LeftButton:  # if the released button is the left button, documentation: https://doc.qt.io/qt-6/qt.html#MouseButton-enum ,&#10;            self.drawing = False  # exit drawing mode&#10;&#10;    # paint events&#10;    def paintEvent(self, event):&#10;        # you should only create and use the QPainter object in this method, it should be a local variable&#10;        canvasPainter = QPainter(self)  # create a new QPainter object, documentation: https://doc.qt.io/qt-6/qpainter.html&#10;        canvasPainter.drawPixmap(QPoint(),self.image)  # draw the image , documentation: https://doc.qt.io/qt-6/qpainter.html#drawImage-1&#10;&#10;    # resize event - this function is called&#10;    def resizeEvent(self, event):&#10;        self.image = self.image.scaled(self.width(), self.height())&#10;&#10;    # slots&#10;    def save(self):&#10;        filePath, _ = QFileDialog.getSaveFileName(self, &quot;Save Image&quot;, &quot;&quot;,&#10;                                                  &quot;PNG(*.png);;JPG(*.jpg *.jpeg);;All Files (*.*)&quot;)&#10;        if filePath == &quot;&quot;:  # if the file path is empty&#10;            return  # do nothing and return&#10;        self.image.save(filePath)  # save file image to the file path&#10;&#10;    def clear(self):&#10;        # reset canvas to the provided canvas image&#10;        self.image = QPixmap(&quot;./icons/canvas.png&quot;)&#10;        self.update()&#10;&#10;    def threepx(self):&#10;        self.brushSize = 3&#10;        self.sizeLabel.setText(&quot;3 px&quot;)&#10;&#10;    def fivepx(self):&#10;        self.brushSize = 5&#10;        self.sizeLabel.setText(&quot;5 px&quot;)&#10;&#10;    def sevenpx(self):&#10;        self.brushSize = 7&#10;        self.sizeLabel.setText(&quot;7 px&quot;)&#10;&#10;    def ninepx(self):&#10;        self.brushSize = 9&#10;        self.sizeLabel.setText(&quot;9 px&quot;)&#10;&#10;    def black(self):&#10;        self.brushColor = Qt.GlobalColor.black&#10;        self.colorIndicator.setStyleSheet(&quot;background-color: #000000; border: 1px solid #000000;&quot;)&#10;        self.colorNameLabel.setText(&quot;Black&quot;)&#10;&#10;    def red(self):&#10;        self.brushColor = Qt.GlobalColor.red&#10;        self.colorIndicator.setStyleSheet(&quot;background-color: #cc0000; border: 1px solid #000000;&quot;)&#10;        self.colorNameLabel.setText(&quot;Red&quot;)&#10;&#10;    def green(self):&#10;        self.brushColor = Qt.GlobalColor.green&#10;        self.colorIndicator.setStyleSheet(&quot;background-color: #008800; border: 1px solid #000000;&quot;)&#10;        self.colorNameLabel.setText(&quot;Green&quot;)&#10;&#10;    def yellow(self):&#10;        self.brushColor = Qt.GlobalColor.yellow&#10;        self.colorIndicator.setStyleSheet(&quot;background-color: #ffdd00; border: 1px solid #000000;&quot;)&#10;        self.colorNameLabel.setText(&quot;Yellow&quot;)&#10;&#10;    # Guess handling&#10;    def handle_guess(self):&#10;        # only accept guesses during guess phase&#10;        if not self.isGuessPhase:&#10;            return&#10;        guess = self.guessInput.text().strip()&#10;        if not guess:&#10;            return&#10;        # compare case-insensitive&#10;        if guess.lower() == self.currentWord.lower():&#10;            # correct&#10;            self.scores[self.currentPlayerNum] += 1&#10;            self.scoreLabels[self.currentPlayerNum].setText(&#10;                f&quot;{self.players[self.currentPlayerNum]}: {self.scores[self.currentPlayerNum]}&quot;)&#10;            self.attemptsLabel.setText(&quot;Correct! Word: &quot; + self.currentWord)&#10;            self.wordLabel.setText(self.currentWord)&#10;            self.isGuessPhase = False&#10;            self.guessOver = True&#10;        else:&#10;            # wrong guess&#10;            self.attemptsLeft -= 1&#10;            if self.attemptsLeft &lt;= 0:&#10;                self.attemptsLabel.setText(&quot;No attempts left. Word: &quot; + self.currentWord)&#10;                self.wordLabel.setText(self.currentWord)&#10;                self.isGuessPhase = False&#10;                self.guessOver = True&#10;            else:&#10;                self.attemptsLabel.setText(f&quot;Wrong. Attempts left: {self.attemptsLeft}&quot;)&#10;        self.guessInput.clear()&#10;&#10;    def start_guess_phase(self):&#10;        # Enter guessing phase: the player after the drawer will be the guesser&#10;        self.isGuessPhase = True&#10;        self.guessOver = False&#10;        self.attemptsLeft = 3&#10;        guesser = (self.playerNum + 1) % len(self.players)&#10;        self.currentPlayerNum = guesser&#10;        self.currentPlayerLabel.setText(f&quot;{self.players[self.currentPlayerNum]}&quot;)&#10;        # hide the word from the guesser (show placeholder)&#10;        self.wordLabel.setText(&quot;----------&quot;)&#10;        self.attemptsLabel.setText(f&quot;Attempts left: {self.attemptsLeft}&quot;)&#10;&#10;    def end_guess_phase_and_start_next_drawer(self):&#10;        # Move drawer forward and prepare new word for the next drawer&#10;        self.playerNum = (self.playerNum + 1) % len(self.players)&#10;        self.currentPlayerNum = self.playerNum&#10;        self.currentPlayerLabel.setText(f&quot;{self.players[self.currentPlayerNum]}&quot;)&#10;        # new word for the new drawer&#10;        self.getList(self.mode)&#10;        self.currentWord = self.getWord()&#10;        self.wordLabel.setText(self.currentWord)&#10;        self.isGuessPhase = False&#10;        self.guessOver = False&#10;        self.attemptsLabel.setText(&quot;&quot;)&#10;&#10;    # Get a random word from the list read from file&#10;    def getWord(self):&#10;        if not self.wordList:&#10;            return &quot;&quot;&#10;        return random.choice(self.wordList)&#10;&#10;    # read word list from file&#10;    def getList(self, mode):&#10;        # Read either comma-separated or one-word-per-line files and build a flat list&#10;        words = []&#10;        try:&#10;            with open(mode + 'mode.txt', encoding='utf-8') as csv_file:&#10;                csv_reader = csv.reader(csv_file)&#10;                for row in csv_reader:&#10;                    # row may be a list of values; extend the words list&#10;                    for token in row:&#10;                        token = token.strip()&#10;                        if token:&#10;                            words.append(token)&#10;        except FileNotFoundError:&#10;            words = []&#10;        self.wordList = words&#10;&#10;        # open a file&#10;        # open a file&#10;&#10;    def open(self):&#10;        '''&#10;        This is an additional function which is not part of the tutorial. It will allow you to:&#10;         - open a file dialog box,&#10;         - filter the list of files according to file extension&#10;         - set the QImage of your application (self.image) to a scaled version of the file)&#10;         - update the widget&#10;        '''&#10;        filePath, _ = QFileDialog.getOpenFileName(self, &quot;Open Image&quot;, &quot;&quot;,&#10;                                                  &quot;PNG(*.png);;JPG(*.jpg *.jpeg);;All Files (*.*)&quot;)&#10;        if filePath == &quot;&quot;:  # if not file is selected exit&#10;            return&#10;        with open(filePath, 'rb') as f:  # open the file in binary mode for reading&#10;            content = f.read()  # read the file&#10;        self.image.loadFromData(content)  # load the data into the file&#10;        width = self.width()  # get the width of the current QImage in your application&#10;        height = self.height()  # get the height of the current QImage in your application&#10;        self.image = self.image.scaled(width, height)  # scale the image from file and put it in your QImage&#10;        self.update()  # call the update method of the widget which calls the paintEvent of this class&#10;&#10;    # change mode between easy and hard&#10;    def set_mode(self, mode: str):&#10;        self.mode = mode&#10;        self.getList(mode)&#10;        self.currentWord = self.getWord()&#10;        if not self.isGuessPhase:&#10;            self.wordLabel.setText(self.currentWord)&#10;&#10;    def next_turn(self):&#10;        if not self.isGuessPhase and not self.guessOver:&#10;            self.start_guess_phase()&#10;        else:&#10;            self.end_guess_phase_and_start_next_drawer()&#10;&#10;&#10;# this code will be executed if it is the main module but not if the module is imported&#10;#  https://stackoverflow.com/questions/419163/what-does-if-name-main-do&#10;if __name__ == &quot;__main__&quot;:&#10;    app = QApplication(sys.argv)&#10;    window = PictionaryGame()&#10;    window.show()&#10;    app.exec()  # start the event loop running&#10;" />
              <option name="updatedContent" value="# Inspired by PyQt5 Creating Paint Application In 40 Minutes&#10;#  https://www.youtube.com/watch?v=qEgyGyVA1ZQ&#10;&#10;# NB If the menus do not work then click on another application and then click back&#10;# and they will work https://python-forum.io/Thread-Tkinter-macOS-Catalina-and-Python-menu-issue&#10;&#10;# PyQt documentation links are prefixed with the word 'documentation' in the code below and can be accessed automatically&#10;#  in PyCharm using the following technique https://www.jetbrains.com/help/pycharm/inline-documentation.html&#10;&#10;from PyQt6.QtWidgets import QApplication, QWidget, QMainWindow, QFileDialog, QDockWidget, QPushButton, QVBoxLayout, \&#10;    QLabel, QSizePolicy, QHBoxLayout, QRadioButton, QLineEdit&#10;from PyQt6.QtGui import QIcon, QPainter, QPen, QPixmap&#10;import sys&#10;import csv, random&#10;from PyQt6.QtCore import Qt, QPoint&#10;&#10;&#10;class PictionaryGame(QMainWindow):  # documentation https://doc.qt.io/qt-6/qwidget.html&#10;    '''&#10;    Painting Application class&#10;    '''&#10;&#10;    def __init__(self):&#10;        super().__init__()&#10;&#10;        # set window title&#10;        self.setWindowTitle(&quot;Pictionary Game - A2 Template&quot;)&#10;&#10;        # set the windows dimensions&#10;        top = 400&#10;        left = 400&#10;        width = 800&#10;        height = 600&#10;        self.setGeometry(top, left, width, height)&#10;&#10;        # set the icon&#10;        self.setWindowIcon(QIcon(&quot;./icons/paint-brush.png&quot;))&#10;&#10;        # canvas image&#10;        self.image = QPixmap(&quot;./icons/canvas.png&quot;)&#10;&#10;        mainWidget = QWidget()&#10;        self.setCentralWidget(mainWidget)&#10;        # Ensure the central widget expands to fill available space so docks&#10;        # will be at the window edges&#10;        mainWidget.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)&#10;&#10;        # draw settings (default)&#10;        self.drawing = False&#10;        self.brushSize = 3&#10;        self.brushColor = Qt.GlobalColor.black&#10;&#10;        # reference to last point recorded by mouse&#10;        self.lastPoint = QPoint()&#10;&#10;        # players and scores&#10;        self.players = [&quot;Player 1&quot;, &quot;Player 2&quot;]&#10;        self.playerNum = 0  # current drawer index&#10;        self.currentPlayerNum = self.playerNum  # shown in &quot;Current Turn&quot;&#10;        self.scores = [0 for _ in self.players]&#10;&#10;        # mode and words&#10;        self.mode = 'easy'&#10;        self.wordList = []&#10;        self.currentWord = &quot;&quot;&#10;&#10;        # guessing state&#10;        self.isGuessPhase = False&#10;        self.attemptsLeft = 0&#10;        self.guessOver = False&#10;&#10;        # Left dock (player info + guessing)&#10;        self.leftDock = QDockWidget()&#10;        self.leftDock.setAllowedAreas(Qt.DockWidgetArea.LeftDockWidgetArea)&#10;        self.leftDock.setFeatures(QDockWidget.DockWidgetFeature(0))&#10;        self.addDockWidget(Qt.DockWidgetArea.LeftDockWidgetArea, self.leftDock)&#10;&#10;        # widget inside the left Dock&#10;        playerInfo = QWidget()&#10;        self.leftLayout = QVBoxLayout()&#10;        playerInfo.setLayout(self.leftLayout)&#10;        playerInfo.setMaximumSize(200, self.height())&#10;&#10;        # Current turn&#10;        self.currentTurnLabel = QLabel(&quot;Current Turn:&quot;)&#10;        self.currentPlayerLabel = QLabel(f&quot;{self.players[self.currentPlayerNum]}&quot;)&#10;        self.leftLayout.addWidget(self.currentTurnLabel)&#10;        self.leftLayout.addWidget(self.currentPlayerLabel)&#10;        self.leftLayout.addSpacing(10)&#10;&#10;        # Scores&#10;        self.leftLayout.addWidget(QLabel(&quot;Scores:&quot;))&#10;        self.scoreLabels = [QLabel(f&quot;{self.players[0]}: {self.scores[0]}&quot;),&#10;                            QLabel(f&quot;{self.players[1]}: {self.scores[1]}&quot;)]&#10;        self.leftLayout.addWidget(self.scoreLabels[0])&#10;        self.leftLayout.addWidget(self.scoreLabels[1])&#10;        self.leftLayout.addSpacing(8)&#10;&#10;        # Play mode&#10;        self.leftLayout.addWidget(QLabel(&quot;Play Mode:&quot;))&#10;        self.radioEasy = QRadioButton(&quot;Easy&quot;)&#10;        self.radioHard = QRadioButton(&quot;Hard&quot;)&#10;        self.radioEasy.setChecked(True)&#10;        self.leftLayout.addWidget(self.radioEasy)&#10;        self.leftLayout.addWidget(self.radioHard)&#10;        self.radioEasy.toggled.connect(lambda checked: self.set_mode('easy') if checked else None)&#10;        self.radioHard.toggled.connect(lambda checked: self.set_mode('hard') if checked else None)&#10;        self.leftLayout.addSpacing(10)&#10;&#10;        # Current word (visible)&#10;        self.leftLayout.addWidget(QLabel(&quot;Current Word:&quot;))&#10;        self.wordLabel = QLabel(&quot;----------&quot;)&#10;        self.leftLayout.addWidget(self.wordLabel)&#10;        self.leftLayout.addSpacing(8)&#10;&#10;        # Guessing UI (always visible)&#10;        self.guessInput = QLineEdit()&#10;        self.guessInput.setPlaceholderText(&quot;Enter your guess here&quot;)&#10;        self.guessButton = QPushButton(&quot;Guess&quot;)&#10;        self.guessButton.clicked.connect(self.handle_guess)&#10;        self.attemptsLabel = QLabel(&quot;&quot;)&#10;        guessLayout = QVBoxLayout()&#10;        guessLayout.addWidget(self.guessInput)&#10;        guessLayout.addWidget(self.guessButton)&#10;        guessLayout.addWidget(self.attemptsLabel)&#10;        self.leftLayout.addLayout(guessLayout)&#10;&#10;        # Next Turn button&#10;        self.nextTurnButton = QPushButton(&quot;Next Turn&quot;)&#10;        self.nextTurnButton.clicked.connect(self.next_turn)&#10;        self.leftLayout.addWidget(self.nextTurnButton)&#10;&#10;        # style left dock&#10;        playerInfo.setAutoFillBackground(True)&#10;        p = playerInfo.palette()&#10;        p.setColor(playerInfo.backgroundRole(), Qt.GlobalColor.lightGray)&#10;        playerInfo.setPalette(p)&#10;        self.leftDock.setWidget(playerInfo)&#10;&#10;        # Right dock (tools)&#10;        self.rightDock = QDockWidget()&#10;        self.rightDock.setAllowedAreas(Qt.DockWidgetArea.RightDockWidgetArea)&#10;        self.rightDock.setFeatures(QDockWidget.DockWidgetFeature(0))&#10;        self.addDockWidget(Qt.DockWidgetArea.RightDockWidgetArea, self.rightDock)&#10;&#10;        # widget inside the right Dock&#10;        colorPalette = QWidget()&#10;        self.rightLayout = QVBoxLayout()&#10;        colorPalette.setLayout(self.rightLayout)&#10;        colorPalette.setMaximumSize(200, self.height())&#10;&#10;        # Color palette controls&#10;        self.rightLayout.addWidget(QLabel(&quot;Color Palette:&quot;))&#10;        self.rightLayout.addSpacing(6)&#10;&#10;        self.btn_black = QPushButton(&quot;Black&quot;)&#10;        self.btn_black.setStyleSheet(&quot;background-color: #000000; color: #ffffff;&quot;)&#10;        self.btn_black.clicked.connect(self.black)&#10;        self.rightLayout.addWidget(self.btn_black)&#10;&#10;        self.btn_red = QPushButton(&quot;Red&quot;)&#10;        self.btn_red.setStyleSheet(&quot;background-color: #cc0000; color: #ffffff;&quot;)&#10;        self.btn_red.clicked.connect(self.red)&#10;        self.rightLayout.addWidget(self.btn_red)&#10;&#10;        self.btn_green = QPushButton(&quot;Green&quot;)&#10;        self.btn_green.setStyleSheet(&quot;background-color: #008800; color: #ffffff;&quot;)&#10;        self.btn_green.clicked.connect(self.green)&#10;        self.rightLayout.addWidget(self.btn_green)&#10;&#10;        self.btn_yellow = QPushButton(&quot;Yellow&quot;)&#10;        self.btn_yellow.setStyleSheet(&quot;background-color: #ffdd00; color: #000000;&quot;)&#10;        self.btn_yellow.clicked.connect(self.yellow)&#10;        self.rightLayout.addWidget(self.btn_yellow)&#10;        self.rightLayout.addStretch(1)&#10;&#10;        # Visual status and brush sizes&#10;        self.rightLayout.addWidget(QLabel(&quot;Current:&quot;))&#10;        swatchLayout = QHBoxLayout()&#10;        self.colorIndicator = QLabel()&#10;        self.colorIndicator.setFixedSize(20, 20)&#10;        self.colorIndicator.setStyleSheet(&quot;background-color: #000000; border: 1px solid #000000;&quot;)&#10;        swatchLayout.addWidget(self.colorIndicator)&#10;        self.colorNameLabel = QLabel(&quot;Black&quot;)&#10;        swatchLayout.addWidget(self.colorNameLabel)&#10;        self.sizeLabel = QLabel(f&quot;{self.brushSize} px&quot;)&#10;        swatchLayout.addWidget(self.sizeLabel)&#10;        swatchLayout.addStretch(1)&#10;        self.rightLayout.addLayout(swatchLayout)&#10;        self.rightLayout.addSpacing(6)&#10;&#10;        # Brush size buttons&#10;        self.rightLayout.addWidget(QLabel(&quot;Brush Sizes:&quot;))&#10;        self.threePxButton = QPushButton(&quot;3 px&quot;)&#10;        self.threePxButton.clicked.connect(self.threepx)&#10;        self.rightLayout.addWidget(self.threePxButton)&#10;&#10;        self.fivePxButton = QPushButton(&quot;5 px&quot;)&#10;        self.fivePxButton.clicked.connect(self.fivepx)&#10;        self.rightLayout.addWidget(self.fivePxButton)&#10;&#10;        self.sevenPxButton = QPushButton(&quot;7 px&quot;)&#10;        self.sevenPxButton.clicked.connect(self.sevenpx)&#10;        self.rightLayout.addWidget(self.sevenPxButton)&#10;&#10;        self.ninePxButton = QPushButton(&quot;9 px&quot;)&#10;        self.ninePxButton.clicked.connect(self.ninepx)&#10;        self.rightLayout.addWidget(self.ninePxButton)&#10;&#10;        self.rightLayout.addStretch(1)&#10;&#10;        # Clear and Save buttons&#10;        self.clearButton = QPushButton(&quot;Clear Canvas&quot;)&#10;        self.clearButton.clicked.connect(self.clear)&#10;        self.rightLayout.addWidget(self.clearButton)&#10;&#10;        self.saveButton = QPushButton(&quot;Save Canvas&quot;)&#10;        self.saveButton.clicked.connect(self.save)&#10;        self.rightLayout.addWidget(self.saveButton)&#10;&#10;        # right dock appearance&#10;        colorPalette.setAutoFillBackground(True)&#10;        p = colorPalette.palette()&#10;        p.setColor(colorPalette.backgroundRole(), Qt.GlobalColor.lightGray)&#10;        colorPalette.setPalette(p)&#10;        self.rightDock.setWidget(colorPalette)&#10;&#10;        # Load initial words and pick one&#10;        self.getList(self.mode)&#10;        self.currentWord = self.getWord()&#10;        self.wordLabel.setText(self.currentWord)&#10;&#10;    # event handlers&#10;    def mousePressEvent(self,event):  # when the mouse is pressed, documentation: https://doc.qt.io/qt-6/qwidget.html#mousePressEvent&#10;        if event.button() == Qt.MouseButton.LeftButton:  # if the pressed button is the left button&#10;            self.drawing = True  # enter drawing mode&#10;            self.lastPoint = event.pos()  # save the location of the mouse press as the lastPoint&#10;            print(self.lastPoint)  # print the lastPoint for debugging purposes&#10;&#10;    def mouseMoveEvent(self,event):  # when the mouse is moved, documenation: documentation: https://doc.qt.io/qt-6/qwidget.html#mouseMoveEvent&#10;        if self.drawing:&#10;            painter = QPainter(self.image)  # object which allows drawing to take place on an image&#10;            # allows the selection of brush colour, brish size, line type, cap type, join type. Images available here http://doc.qt.io/qt-6/qpen.html&#10;            painter.setPen(QPen(self.brushColor, self.brushSize, Qt.PenStyle.SolidLine, Qt.PenCapStyle.RoundCap,Qt.PenJoinStyle.RoundJoin))&#10;            painter.drawLine(self.lastPoint,event.pos())  # draw a line from the point of the orginal press to the point to where the mouse was dragged to&#10;            self.lastPoint = event.pos()  # set the last point to refer to the point we have just moved to, this helps when drawing the next line segment&#10;            self.update()  # call the update method of the widget which calls the paintEvent of this class&#10;&#10;    def mouseReleaseEvent(self,event):  # when the mouse is released, documentation: https://doc.qt.io/qt-6/qwidget.html#mouseReleaseEvent&#10;        if event.button() == Qt.MouseButton.LeftButton:  # if the released button is the left button, documentation: https://doc.qt.io/qt-6/qt.html#MouseButton-enum ,&#10;            self.drawing = False  # exit drawing mode&#10;&#10;    # paint events&#10;    def paintEvent(self, event):&#10;        # you should only create and use the QPainter object in this method, it should be a local variable&#10;        canvasPainter = QPainter(self)  # create a new QPainter object, documentation: https://doc.qt.io/qt-6/qpainter.html&#10;        canvasPainter.drawPixmap(QPoint(),self.image)  # draw the image , documentation: https://doc.qt.io/qt-6/qpainter.html#drawImage-1&#10;&#10;    # resize event - this function is called&#10;    def resizeEvent(self, event):&#10;        self.image = self.image.scaled(self.width(), self.height())&#10;&#10;    # slots&#10;    def save(self):&#10;        filePath, _ = QFileDialog.getSaveFileName(self, &quot;Save Image&quot;, &quot;&quot;,&#10;                                                  &quot;PNG(*.png);;JPG(*.jpg *.jpeg);;All Files (*.*)&quot;)&#10;        if filePath == &quot;&quot;:  # if the file path is empty&#10;            return  # do nothing and return&#10;        self.image.save(filePath)  # save file image to the file path&#10;&#10;    def clear(self):&#10;        # reset canvas to the provided canvas image&#10;        self.image = QPixmap(&quot;./icons/canvas.png&quot;)&#10;        self.update()&#10;&#10;    def threepx(self):&#10;        self.brushSize = 3&#10;        self.sizeLabel.setText(&quot;3 px&quot;)&#10;&#10;    def fivepx(self):&#10;        self.brushSize = 5&#10;        self.sizeLabel.setText(&quot;5 px&quot;)&#10;&#10;    def sevenpx(self):&#10;        self.brushSize = 7&#10;        self.sizeLabel.setText(&quot;7 px&quot;)&#10;&#10;    def ninepx(self):&#10;        self.brushSize = 9&#10;        self.sizeLabel.setText(&quot;9 px&quot;)&#10;&#10;    def black(self):&#10;        self.brushColor = Qt.GlobalColor.black&#10;        self.colorIndicator.setStyleSheet(&quot;background-color: #000000; border: 1px solid #000000;&quot;)&#10;        self.colorNameLabel.setText(&quot;Black&quot;)&#10;&#10;    def red(self):&#10;        self.brushColor = Qt.GlobalColor.red&#10;        self.colorIndicator.setStyleSheet(&quot;background-color: #cc0000; border: 1px solid #000000;&quot;)&#10;        self.colorNameLabel.setText(&quot;Red&quot;)&#10;&#10;    def green(self):&#10;        self.brushColor = Qt.GlobalColor.green&#10;        self.colorIndicator.setStyleSheet(&quot;background-color: #008800; border: 1px solid #000000;&quot;)&#10;        self.colorNameLabel.setText(&quot;Green&quot;)&#10;&#10;    def yellow(self):&#10;        self.brushColor = Qt.GlobalColor.yellow&#10;        self.colorIndicator.setStyleSheet(&quot;background-color: #ffdd00; border: 1px solid #000000;&quot;)&#10;        self.colorNameLabel.setText(&quot;Yellow&quot;)&#10;&#10;    # Guess handling&#10;    def handle_guess(self):&#10;        # only accept guesses during guess phase&#10;        if not self.isGuessPhase:&#10;            return&#10;        guess = self.guessInput.text().strip()&#10;        if not guess:&#10;            return&#10;        # compare case-insensitive&#10;        if guess.lower() == self.currentWord.lower():&#10;            # correct&#10;            self.scores[self.currentPlayerNum] += 1&#10;            self.scoreLabels[self.currentPlayerNum].setText(&#10;                f&quot;{self.players[self.currentPlayerNum]}: {self.scores[self.currentPlayerNum]}&quot;)&#10;            self.attemptsLabel.setText(&quot;Correct! Word: &quot; + self.currentWord)&#10;            self.wordLabel.setText(self.currentWord)&#10;            self.isGuessPhase = False&#10;            self.guessOver = True&#10;        else:&#10;            # wrong guess&#10;            self.attemptsLeft -= 1&#10;            if self.attemptsLeft &lt;= 0:&#10;                self.attemptsLabel.setText(&quot;No attempts left. Word: &quot; + self.currentWord)&#10;                self.wordLabel.setText(self.currentWord)&#10;                self.isGuessPhase = False&#10;                self.guessOver = True&#10;            else:&#10;                self.attemptsLabel.setText(f&quot;Wrong. Attempts left: {self.attemptsLeft}&quot;)&#10;        self.guessInput.clear()&#10;&#10;    def start_guess_phase(self):&#10;        # Enter guessing phase: the player after the drawer will be the guesser&#10;        self.isGuessPhase = True&#10;        self.guessOver = False&#10;        self.attemptsLeft = 3&#10;        guesser = (self.playerNum + 1) % len(self.players)&#10;        self.currentPlayerNum = guesser&#10;        self.currentPlayerLabel.setText(f&quot;{self.players[self.currentPlayerNum]}&quot;)&#10;        # hide the word from the guesser (show placeholder)&#10;        self.wordLabel.setText(&quot;----------&quot;)&#10;        self.attemptsLabel.setText(f&quot;Attempts left: {self.attemptsLeft}&quot;)&#10;&#10;    def end_guess_phase_and_start_next_drawer(self):&#10;        # Move drawer forward and prepare new word for the next drawer&#10;        self.playerNum = (self.playerNum + 1) % len(self.players)&#10;        self.currentPlayerNum = self.playerNum&#10;        self.currentPlayerLabel.setText(f&quot;{self.players[self.currentPlayerNum]}&quot;)&#10;        # new word for the new drawer&#10;        self.getList(self.mode)&#10;        self.currentWord = self.getWord()&#10;        self.wordLabel.setText(self.currentWord)&#10;        self.isGuessPhase = False&#10;        self.guessOver = False&#10;        self.attemptsLabel.setText(&quot;&quot;)&#10;&#10;    # Get a random word from the list read from file&#10;    def getWord(self):&#10;        if not self.wordList:&#10;            return &quot;&quot;&#10;        return random.choice(self.wordList)&#10;&#10;    # read word list from file&#10;    def getList(self, mode):&#10;        # Read either comma-separated or one-word-per-line files and build a flat list&#10;        words = []&#10;        try:&#10;            with open(mode + 'mode.txt', encoding='utf-8') as csv_file:&#10;                csv_reader = csv.reader(csv_file)&#10;                for row in csv_reader:&#10;                    # row may be a list of values; extend the words list&#10;                    for token in row:&#10;                        token = token.strip()&#10;                        if token:&#10;                            words.append(token)&#10;        except FileNotFoundError:&#10;            words = []&#10;        self.wordList = words&#10;&#10;        # open a file&#10;        # open a file&#10;&#10;    def open(self):&#10;        '''&#10;        This is an additional function which is not part of the tutorial. It will allow you to:&#10;         - open a file dialog box,&#10;         - filter the list of files according to file extension&#10;         - set the QImage of your application (self.image) to a scaled version of the file)&#10;         - update the widget&#10;        '''&#10;        filePath, _ = QFileDialog.getOpenFileName(self, &quot;Open Image&quot;, &quot;&quot;,&#10;                                                  &quot;PNG(*.png);;JPG(*.jpg *.jpeg);;All Files (*.*)&quot;)&#10;        if filePath == &quot;&quot;:  # if not file is selected exit&#10;            return&#10;        with open(filePath, 'rb') as f:  # open the file in binary mode for reading&#10;            content = f.read()  # read the file&#10;        self.image.loadFromData(content)  # load the data into the file&#10;        width = self.width()  # get the width of the current QImage in your application&#10;        height = self.height()  # get the height of the current QImage in your application&#10;        self.image = self.image.scaled(width, height)  # scale the image from file and put it in your QImage&#10;        self.update()  # call the update method of the widget which calls the paintEvent of this class&#10;&#10;    # change mode between easy and hard&#10;    def set_mode(self, mode: str):&#10;        self.mode = mode&#10;        self.getList(mode)&#10;        self.currentWord = self.getWord()&#10;        if not self.isGuessPhase:&#10;            self.wordLabel.setText(self.currentWord)&#10;&#10;    def next_turn(self):&#10;        if not self.isGuessPhase and not self.guessOver:&#10;            self.start_guess_phase()&#10;        else:&#10;            self.end_guess_phase_and_start_next_drawer()&#10;&#10;&#10;# this code will be executed if it is the main module but not if the module is imported&#10;#  https://stackoverflow.com/questions/419163/what-does-if-name-main-do&#10;if __name__ == &quot;__main__&quot;:&#10;    app = QApplication(sys.argv)&#10;    window = PictionaryGame()&#10;    window.show()&#10;    app.exec()  # start the event loop running" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>